<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>var/let/const</title></head><body><h2>var/let/const 区别(请在控制台查看)</h2>1.声明(同一区域声明)<hr/>2.声明(不同区域)<hr/>3.const 阻止的是对于变量绑定的值,而不阻止对成员值的修改<hr/>4.暂时性死区域<hr/>5.暂时性死区域的解决办法<hr/>6.单纯的for循环<hr/>7.for循环+setTimeout()<hr/>8.赋值<hr/></body><script>    // {    //     //声明(同一区域声明)    //     /**    //      * var: 同一变量在同一区域声明多次后者覆盖前者    //      * let/const: 同一变量在同一区域不能声明多次    //      * */    //     var a = 0;    //     var a = 1;    //     console.log(a,'var'); // 1 会覆盖    //     let b = 0;    //     let b = 1;    //     console.log(b,'let');//报错    //     const c = 0;    //     const c = 1;    //     console.log(c,'const')//报错    //    // }    // {    //     //声明(不同区域)    //     var a = 0;    //     function fn() {    //         var a = 1;    //         console.log(a,'var 内')    //     }    //     fn();    //     console.log(a,'var 外');    //    //     let b = 0;    //     function fnb() {    //         let b = 1;    //         console.log(b,'let 内')    //     }    //     fnb();    //     console.log(b,'let 外');    //    //     const c = 0;    //     function fnc() {    //         const c = 1;    //         console.log(c,'const 内')    //     }    //     fnc();    //     console.log(c,'const 外')    // }    // {    //     //const 阻止的是对于变量绑定的值,而不阻止对成员值的修改    //     const c ={name:"name1"};    //     c.name = 'name2'; //不报错    //     console.log(c.name,'改变')    //    // c = {name:'name3'} //报错    // }    // {    //     // 1. 暂时性死区域    //        //var声明的话会分为    //     if (true){    //         console.log(typeof  a); ////undefined    //         var a = 'a';    //     }    //     /**    //      * if (true){    //      *  var a;    //         console.log(typeof  a);    //         a = 'a';    //     }    //      * **/    //     //用 let和const 声明的话会出现暂时性死区域    //     if (true){    //         console.log(typeof  b);//报错    //         let b = 'b';    //     }    //     if (true){    //         console.log(typeof  c);//报错    //         const c = 'c';    //     }    // }    // {    //     // 2. 暂时性死区域,解决    //     console.log(typeof  b);//undefined    //     if (true){    //         let b = 'b';    //     }    //     console.log(typeof  c);//undefined    //     if (true){    //         const c = 'c';    //     }    // }    // {    //   //  单纯的for循环 对比var/let/const    //   for (var i =0;i<10;i++){    //       console.log(i,'var')    //   }    //   for (let o =0;o<10;o++){    //       console.log(o,'let')    //   }    //   for (const j=0;j<10;j++){    //        console.log(j,'const')    //   }    //    // const声明后的值不能更改,当第二次循环是 j 会别改变，会报错    // }    // {    //     //  for循环+setTimeout() 对比var/let/const    //     /**    //      * var: 会打印 10次10,解决办法利用闭包或者立即执行函数    //      * let: 会打印 0-9    //      * const: 报错同for循环    //      * **/    //     // for (var i =0;i<10;i++){    //     //     setTimeout(function () {    //     //         console.log(i,'var')    //     //     },0)    //     // }    //     //解决var声明这个问题 用闭包/立即执行函数    //        /**    //         * 立即执行函数:    //         *    创造了新的函数作用域将A函数(也可以写成匿名函数)包裹了起来，并用k捕获了每次循环时的i    //         * **/    //     for (var i =0;i<10;i++){    //         (function () {    //             var k =i;    //             setTimeout(function A() {    //             // setTimeout(function () {    //                 console.log(k,'var k 立即执行')    //             },0)    //         })()    //     }    //     /**    //      * 闭包:    //      *  用新的变量a把变量i每次的值保存下来    //      **/    //     for (var i =0;i<10;i++){    //         (function (a) {    //             setTimeout(function () {    //                 console.log(a,'var i 闭包')    //             },0)    //         })(i)    //     }    //    //     // for (let o =0;o<10;o++){    //     //     setTimeout(function () {    //     //         console.log(o,'let')    //     //     },0)    //     // }    //     // for (const j=0;j<10;j++){    //     //     setTimeout(function () {    //     //         console.log(j,'const')    //     //     },0)    //     // }    // }    // {    //   //赋值    //     /**    //      * 对象的解构与数组有一个重要的不同    //      * 数组的元素是按次序排列的，变量的取值由它的位置决定    //      * 对象的属性没有次序，变量必须与属性同名，才能取到正确的值    //      * **/    //     let [a,b,c] =[1,2,3];    //     console.log([a,b,c]);    //     let [q,w,[e,r],t] = [1,2,[3,4,],5];    //     console.log([q,w,[e,r],t]);    //     /**    //      * 解构的默认值    //      * 如果有初始值，后来没有赋值新的就用初始值    //      * 如果有初始值，后来赋值新的值为undefined代表没有赋值还用初始值    //      * 如果有初始值，后来赋值新的值为null就用null    //      * 如果没有初始值，后来赋值是什么就用什么,即使赋的值为undefined/null 也用 undefined/null    //      * 如果没有初始值，后来也没有赋值,则会自动用 undefined 赋值    //      * **/    //     let [foo1 =true] =[];    //     let [foo2 ='true'] =[];    //     console.log(foo1)//true 布尔类型    //     console.log(foo2)//true 字符串    //     let [aa,bb='bb有默认值'] = ['aa 后来给的值'];    //     let [aaa,bbb='bbb有默认值'] = ['aaa 后来给的值',undefined];    //     let [aaaa,bbbb='bbbb有默认值'] = ['aaaa 后来给的值',null];    //     console.log(aa+bb);//aa 后来给的值bb 有默认值    //     console.log(aaa+bbb);//aaa 后来给的值bbb 有默认值    //     console.log(aaaa+bbbb);//aaaa 后来给的值unll    //     /**    //      * 圆括号的使用    //      * 如果在解构之前就定义了变量，这时候你再解构会出现问题。下面是错误的代码，编译会报错。    //      * 在解构的语句外边加一个圆括号就可以了    //      * **/    //     let obj;    //     //{obj} = {obj:'obj'}//报错    //     ({obj} = {obj:'obj'});    //     console.log(obj);    //     //字符串解构    //     let [z,x,n,v,m] ="字符串解构";    //     console.log(z)    //     console.log(x)    //     console.log(n)    //     console.log(v)    //     console.log(m)    // }</script></html>