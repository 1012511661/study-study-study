<!DOCTYPE html><html lang="en"><head>    <meta charset="UTF-8">    <title>new</title></head><body>将属性写在原型里与将属性写在构造函数里有什么不同<br/>   1、把方法写在原型中比写在构造函数中消耗的内存更小，因为在内存中一个类的原型只有一个，写在原型中的行为可以被所有实例共享，实例化的时候并不会在实例的内存中再复制一份<br/>而写在类中的方法，实例化的时候会在每个实例中再复制一份，所以消耗的内存更高<br/>所以没有特殊原因，我们一般把属性写到类中，而行为写到原型中<br/>2、构造函数中定义的属性和方法要比原型中定义的属性和方法的优先级高，如果定义了同名称的属性和方法，构造函数中的将会覆盖原型中的</body><script>    // {    //     function Person1(){    //         this.name="小A";    //         this.friend="小A的朋友";    //     }    //     Person1.prototype.friend = '';    //     Person1.prototype.name = '';    //     let a = new Person1();    //     a.friend = '志明';    //     a.name = '春娇';    //     let b = new Person1();    //     console.log(a);    //     console.log(a.friend,'a.friend');//志明    //     console.log(a.name,'a.name');//春娇    //    //     console.log(b.friend,'b.friend');//小A的朋友    //     console.log(b.name,'b.name');//小A    // }    // {    //     function Person2(){    //         this.name="小A";    //         this.friend="小A的朋友";    //     }    //     Person2.prototype.friend =[];    //     Person2.prototype.name = '';    //     let a = new Person2();    //     a.friend = '志明';    //     a.name = '春娇';    //     let b = new Person2();    //     console.log(a);    //     console.log(a.friend,'a.friend');//志明    //     console.log(a.name,'a.name');//春娇    //    //     console.log(b.friend,'b.friend');//小A的朋友    //     console.log(b.name,'b.name');//小A    // }    // {    //     function Person3(){    //         this.name="小A";    //         this.friend="小A的朋友";    //     }    //     Person3.prototype.friend =[];    //     Person3.prototype.name = '';    //     let a = new Person3();    //     a.friend[0] = '志明';    //     a.name = '春娇';    //     let b = new Person3();    //     console.log(a);    //     console.log(a.friend,'a.friend');//小A的朋友    //     console.log(a.name,'a.name');//春娇    //    //     console.log(b.friend,'b.friend');//小A的朋友    //     console.log(b.name,'b.name');//小A    // }    // {    //     function Person4(){    //         this.name="小A";    //         this.friend="小A的朋友";    //     }    //     Person4.prototype.friend =[];    //     Person4.prototype.name = '';    //     let a = new Person4();    //     a.friend[0] = '志明';    //    // a.__proto__.friend[0] = '小明_proto_';    //     a.name = '春娇';    //     let b = new Person4();    //     console.log(a);    //     console.log(a.friend,'a.friend');//小A的朋友    //     console.log(a.name,'a.name');//春娇    //    //     console.log(b.friend,'b.friend');//小A的朋友    //     console.log(b.name,'b.name');//小A    // }    // {    //     function Person5(){    //         this.name="小A";    //         this.friend="小A的朋友";    //         this.age = 100;    //     }    //     Person5.prototype.friend =[];    //     Person5.prototype.name = '';    //     Person5.prototype.age = [];    //     let a = new Person5();    //     a.friend[0] = '志明';    //     a.name = '春娇';    //     a.age = 10;    //     console.log(a);    //     console.log(a.friend,'a.friend');    //     console.log(a.friend[0],'a.friend[0]');    //     console.log(a.name,'a.name');    //     console.log(a.age,'a.age');    // }    {            function Person6(){                this.name="小A";                this.friend="小A的朋友";                this.age = 100;                this.tit = "空";            }            Person6.prototype.friend =[];            Person6.prototype.name = '';            Person6.prototype.age = [];            Person6.prototype.tit = [1,2,3];            let a = new Person6();            a.friend[0] = '小6666666666';//并没有改变构造里面friend的第一个值            a.__proto__.friend[0] = '志明';            a.__proto__.tit[0] = 5;            a.name = '春娇';            a.age = 10;            console.log(a);//obj            console.log(a.friend,'a.friend');//小A的朋友 本身没有找构造            console.log(a.friend[0],'a.friend[0]');//小 构造里面friend的第一个字符            console.log(a.__proto__.friend[0],'a.__proto__.friend');//志明   改变原型friend数组里面的第一个值            console.log(a.__proto__.friend,'a.__proto__.friend');//['志明']  原型里面的friend            console.log(a.tit,'a.tit');//空 本身没有找构造            console.log(a.__proto__.tit,'a.__proto__.tit');//[5,2,3] 改变原型tit数组里面的第一个值            console.log(a.name,'a.name');//春娇 本身            console.log(a.age,'a.age');//10 本身        //  构造函数中定义的属性和方法要比原型中定义的属性和方法的优先级高        //  如果定义了同名称的属性和方法，构造函数中的将会覆盖原型中的    }</script></html>